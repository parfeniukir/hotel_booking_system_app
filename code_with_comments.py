# Імпортуємо бібліотеку pandas для роботи з даними у форматі таблиць (DataFrame).
# Вона часто використовується для читання та маніпулювання CSV, Excel та іншими файлами даних.
import pandas as pd

# -------------------------------------------------------------------

# Читаємо файл "hotels.csv" і завантажуємо його вміст у DataFrame під назвою df_hotels.
# Аргумент dtype={"id": str} гарантує, що значення у стовпці "id" будуть інтерпретовані як рядки (string),
# що важливо для уникнення проблем з провідними нулями або некоректним порівнянням.
df_hotels = pd.read_csv("hotels.csv", dtype={"id": str})
# Закоментовані рядки нижче можна використовувати для налагодження:
# print(df_hotels)
# print(type(df_hotels))


# Визначаємо клас Hotel, який представляє окремий готель та його логіку.
class Hotel:
    # Метод-конструктор, який викликається при створенні нового об'єкта Hotel.
    def __init__(self, hotel_id):
        # Зберігаємо ID готелю, переданий при створенні об'єкта.
        self.hotel_id = hotel_id
        # Знаходимо назву готелю в DataFrame df_hotels:
        # 1. df_hotels["id"] == self.hotel_id - фільтруємо рядки, де "id" відповідає ID готелю.
        # 2. .loc[...] - вибираємо ці відфільтровані рядки.
        # 3. ..., "name" - вибираємо значення лише зі стовпця "name".
        # 4. .squeeze() - перетворює отриманий рядок (який є серією pandas) на просте строкове значення (якщо знайдено один результат).
        self.name = df_hotels.loc[df_hotels["id"] == self.hotel_id, "name"].squeeze()
        # print("HOTEL NAME", self.name) # Коментар для налагодження, щоб побачити назву.

    # Метод для "бронювання" готелю.
    def booking(self):
        # Оновлюємо значення в стовпці "available" на "no" для рядка, який відповідає ID поточного готелю.
        # Це позначає готель як заброньований/недоступний.
        df_hotels.loc[df_hotels["id"] == self.hotel_id, "available"] = "no"
        # Зберігаємо оновлений DataFrame назад у файл "hotels.csv".
        # index=False запобігає запису індексів рядків DataFrame у CSV-файл.
        df_hotels.to_csv("hotels.csv", index=False)

    # Метод для перевірки, чи доступний готель для бронювання.
    def available(self):
        """Check if the hotel is available"""  # Документуючий рядок (docstring) для пояснення функції методу.
        # Фільтруємо DataFrame по ID готелю і отримуємо значення зі стовпця "available" для цього готелю.
        available = df_hotels.loc[df_hotels["id"] == self.hotel_id, "available"].squeeze()

        # Обробка можливих помилок за допомогою блоку try-except.
        try:
            # Якщо значення "available" - "yes", повертаємо True (доступний).
            if available == "yes":
                return True
            # Інакше (якщо "no" або інше значення), повертаємо False (недоступний).
            else:
                return False
        # Якщо .squeeze() не може знайти значення (наприклад, ID готелю не існує),
        # він може повернути NaN або викликати іншу несподівану поведінку, яку ми намагаємось зловити.
        # Хоча, якщо ID не існує, available буде pandas.Series, тому краще тут ловити випадок, коли available не є рядком.
        # Простий ValueError тут не зовсім коректний для цієї логіки, але залишаємо як у вихідному коді.
        except ValueError:
            print("This ID is not exist!")
            exit()  # Завершуємо виконання програми, якщо ID не знайдено.
        # Закоментовані рядки для налагодження:
        # print(available)
        # print(type(available))


# -------------------------------------------------------------------


# Визначаємо клас ReservationTicket, який створює квиток (підтвердження) про бронювання.
class ReservationTicket:
    # Конструктор приймає ім'я клієнта та об'єкт готелю (екземпляр класу Hotel).
    def __init__(self, customer_name, hotel_obj):
        self.customer_name = customer_name
        self.hotel_obj = hotel_obj  # Зберігаємо об'єкт готелю для доступу до його властивостей (як-от назва).

    # Метод для генерації тексту квитка/підтвердження.
    def generate(self):
        # Створюємо багаторядковий рядок (f-рядок) з даними бронювання,
        # використовуючи ім'я клієнта та назву готелю з об'єкта `hotel_obj`.
        ticket = f"""
        Thank you for your reservation.
        Here is your booking data:
        Name: {self.customer_name}.
        Hotel name: {self.hotel_obj.name}
        """
        return ticket  # Повертаємо сформований текст квитка.


# -------------------------------------------------------------------


# Визначаємо основну функцію програми, де відбувається логіка взаємодії з користувачем.
def main():
    # Виводимо весь список готелів з їхніми ID та статусом доступності.
    print(df_hotels)

    # Запитуємо у користувача ID готелю, який він хоче забронювати.
    hotel_id = input("Enter the ID of the hotel: ")
    # Створюємо новий об'єкт класу Hotel, використовуючи наданий ID.
    hotel = Hotel(hotel_id=hotel_id)

    # Перевіряємо, чи доступний готель для бронювання, викликаючи метод available().
    if hotel.available():
        # Якщо доступний, викликаємо метод booking(), щоб змінити статус в CSV-файлі на "no".
        hotel.booking()
        # Запитуємо ім'я клієнта.
        customer_name = input("Enter you name: ")
        # Створюємо об'єкт ReservationTicket з ім'ям клієнта та об'єктом готелю.
        reservation_ticket = ReservationTicket(
            customer_name=customer_name,
            hotel_obj=hotel,
        )
        # Генеруємо та виводимо підтвердження бронювання.
        print(reservation_ticket.generate())
    else:
        # Якщо готель недоступний, виводимо відповідне повідомлення.
        print("Sorry, the hotel is not available for booking.")


# -------------------------------------------------------------------

# Цей блок гарантує, що функція main() буде викликана лише тоді, коли файл
# запускається безпосередньо (а не імпортується як модуль в інший файл).
if __name__ == "__main__":
    # Коментар пояснює призначення блоку:
    # перевірка чи запусткається безпосередньо файл main.py
    # якщо ні - то функція main() не буде викликана
    main()  # Запускаємо основну логіку програми.
